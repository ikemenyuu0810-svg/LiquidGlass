<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>Liquid Glass (Free / Single HTML)</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    background:
      linear-gradient(120deg,#0f2027,#203a43,#2c5364);
  }
  canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>
</head>
<body>

<canvas id="gl"></canvas>

<script>
const canvas = document.getElementById("gl");
const gl = canvas.getContext("webgl");
if (!gl) alert("WebGL not supported");

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  gl.viewport(0,0,canvas.width,canvas.height);
}
addEventListener("resize", resize);
resize();

const vertexSrc = `
attribute vec2 p;
varying vec2 v;
void main(){
  v = p * 0.5 + 0.5;
  gl_Position = vec4(p,0.0,1.0);
}
`;

const fragmentSrc = `
precision highp float;
uniform vec2 r;
uniform float t;
varying vec2 v;

// 疑似流体ノイズ
float noise(vec2 p){
  return sin(p.x)*sin(p.y);
}

void main(){
  vec2 uv = v;

  // ---- Liquid Glass の核：歪む法線 ----
  float n1 = noise(uv*18.0 + t*0.6);
  float n2 = noise(uv*32.0 - t*0.4);
  float n = n1*0.6 + n2*0.4;

  vec2 normal = vec2(
    dFdx(n),
    dFdy(n)
  );

  // ---- 屈折 ----
  float refractPower = 0.04;
  vec2 refractUV = uv + normal * refractPower;

  // 背景（CSS背景を擬似的に再現）
  vec3 bg = mix(
    vec3(0.05,0.15,0.2),
    vec3(0.2,0.4,0.5),
    refractUV.y
  );

  // ---- Fresnel（縁が光る） ----
  float fresnel = pow(
    1.0 - dot(normalize(vec3(normal,1.0)), vec3(0,0,1)),
    3.0
  );

  // ---- ガラス色 ----
  vec3 glass = mix(bg, vec3(1.0), 0.18);
  glass += fresnel * 0.45;

  // ---- Edge（厚み） ----
  float edge =
    smoothstep(0.0,0.18,uv.x) *
    smoothstep(0.0,0.18,uv.y) *
    smoothstep(0.0,0.18,1.0-uv.x) *
    smoothstep(0.0,0.18,1.0-uv.y);

  gl_FragColor = vec4(glass, edge * 0.65);
}
`;

function compile(type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(s));
  }
  return s;
}

const program = gl.createProgram();
gl.attachShader(program, compile(gl.VERTEX_SHADER, vertexSrc));
gl.attachShader(program, compile(gl.FRAGMENT_SHADER, fragmentSrc));
gl.linkProgram(program);
gl.useProgram(program);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(
  gl.ARRAY_BUFFER,
  new Float32Array([-1,-1, 1,-1, -1,1, 1,1]),
  gl.STATIC_DRAW
);

const loc = gl.getAttribLocation(program,"p");
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

const rLoc = gl.getUniformLocation(program,"r");
const tLoc = gl.getUniformLocation(program,"t");

function draw(time){
  gl.uniform2f(rLoc, canvas.width, canvas.height);
  gl.uniform1f(tLoc, time*0.001);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
  requestAnimationFrame(draw);
}
draw(0);
</script>

</body>
</html>
