<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Liquid Glass – Fixed</title>
<style>
html,body{
  margin:0;
  height:100%;
  overflow:hidden;
  background:linear-gradient(120deg,#0f2027,#203a43,#2c5364);
}
canvas{width:100%;height:100%;display:block;}
</style>
</head>
<body>

<canvas id="gl"></canvas>

<script>
const canvas = document.getElementById("gl");
const gl = canvas.getContext("webgl");
if(!gl) alert("WebGL not supported");

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  gl.viewport(0,0,canvas.width,canvas.height);
}
addEventListener("resize",resize);
resize();

const vs = `
attribute vec2 p;
varying vec2 v;
void main(){
  v = p*0.5+0.5;
  gl_Position = vec4(p,0.0,1.0);
}
`;

const fs = `
precision highp float;
uniform float t;
varying vec2 v;

// ノイズ
float n(vec2 p){
  return sin(p.x)*sin(p.y);
}

void main(){
  vec2 uv = v;

  // ---- 疑似法線（dFdx 不使用）----
  float e = 0.002;
  float c = n(uv*20.0 + t*0.6);
  float cx = n((uv+vec2(e,0))*20.0 + t*0.6);
  float cy = n((uv+vec2(0,e))*20.0 + t*0.6);

  vec2 normal = vec2(cx-c, cy-c);

  // ---- 屈折 ----
  vec2 refractUV = uv + normal * 0.08;

  // ---- 背景 ----
  vec3 bg = mix(
    vec3(0.06,0.15,0.22),
    vec3(0.22,0.45,0.6),
    refractUV.y
  );

  // ---- Fresnel ----
  float fresnel = pow(1.0 - length(normal)*6.0, 3.0);

  vec3 glass = mix(bg, vec3(1.0), 0.18);
  glass += fresnel * 0.5;

  // ---- エッジ厚み ----
  float edge =
    smoothstep(0.0,0.18,uv.x) *
    smoothstep(0.0,0.18,uv.y) *
    smoothstep(0.0,0.18,1.0-uv.x) *
    smoothstep(0.0,0.18,1.0-uv.y);

  gl_FragColor = vec4(glass, edge*0.65);
}
`;

function compile(type,src){
  const s = gl.createShader(type);
  gl.shaderSource(s,src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(s));
  }
  return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER,vs));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER,fs));
gl.linkProgram(prog);
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buf);
gl.bufferData(
  gl.ARRAY_BUFFER,
  new Float32Array([-1,-1,1,-1,-1,1,1,1]),
  gl.STATIC_DRAW
);

const loc = gl.getAttribLocation(prog,"p");
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

const tLoc = gl.getUniformLocation(prog,"t");

function draw(time){
  gl.uniform1f(tLoc,time*0.001);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
  requestAnimationFrame(draw);
}
draw(0);
</script>

</body>
</html>
